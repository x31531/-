<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>복합 구조 오디오 반응 아트 – 설명 모달 상단 간격 조정</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/addons/p5.sound.min.js"></script>

<style>
  @font-face {
    font-family: 'OnulSamhwa';
    src: url('OnulSamhwagothic-Regular.otf') format('opentype');
    font-weight: normal;
    font-style: normal;
  }

  /* ---- 컨트롤 버튼 ---- */
  #controls {
    position: fixed;
    top: 12px;
    left: 12px;
    display: flex;
    flex-direction: column;
    gap: 6px;
    z-index: 2000;
  }
  #controls button {
    font-family: 'OnulSamhwa', sans-serif;
    width: 90px;
    height: 30px;
    font-size: 12px;
    color: #fff;
    background: rgba(255,255,255,0.15);
    border: 1px solid rgba(255,255,255,0.3);
    border-radius: 15px;
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
    cursor: pointer;
    transition: background 0.25s, transform 0.15s;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  #controls button:hover {
    background: rgba(255,255,255,0.3);
    transform: translateY(-1px);
  }
  #controls button.active {
    background: rgba(255,255,255,0.35);
    border: 1px solid rgba(255,255,255,0.6);
    transform: scale(0.95);
  }
  #toggleMic img {
    height: 16px;
    width: auto;
    display: block;
  }

  /* 모바일 : 하단 가로 배치 */
  @media (max-width: 768px) {
    #controls {
      top: auto;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      flex-direction: row;
      gap: 8px;
    }
  }

  html,body {margin:0;padding:0;height:100%;background:#000;overflow:hidden;}
  canvas {display:block;}

  /* ---- 설명 모달 (상단 패딩만 줄임) ---- */
  #infoModal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: min(90%, 420px);
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.3);
    border-radius: 20px;
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    /* top right bottom left → 위쪽만 12px */
    padding: 12px 24px 24px 24px;
    color: #fff;
    font-family: 'OnulSamhwa', sans-serif;
    z-index: 3000;
    box-shadow: 0 4px 30px rgba(0,0,0,0.4);
  }
  #infoModal p {
    font-size: 14px;
    line-height: 1.5;
    margin-bottom: 20px;
  }
  #closeModal {
    display: inline-block;
    padding: 6px 16px;
    font-size: 13px;
    color: #fff;
    background: rgba(255,255,255,0.2);
    border: 1px solid rgba(255,255,255,0.4);
    border-radius: 15px;
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
    cursor: pointer;
    transition: background 0.25s;
  }
  #closeModal:hover {
    background: rgba(255,255,255,0.35);
  }
</style>
</head>
<body>

<!-- 컨트롤 버튼 -->
<div id="controls">
  <button id="toggleTrail">누적 ON/OFF</button>
  <button id="clearScreen">클리어</button>
  <button id="toggleMic"><img src="mic-on.png" alt="Mic On Icon" id="micIcon"></button>
</div>

<!-- 설명 모달 -->
<div id="infoModal">
  <p id="description-text">
    소리 기호의 리디자인을 통해 유음과 무음이 동등한 무게감을 갖도록 하는 프로젝트입니다.
    스피커에 X표를 치는 등 부정형으로 표현되어 왔던 기존의 무음 기호와는 달리,
    본 작업에서는 유음과 무음 모두가 독립적인 의미를 갖는 기호를 만들고자 했습니다.
    웹을 통해 제가 제안하는 새로운 소리 기호의 작동 원리를 소개합니다.
  </p>
  <button id="closeModal">닫기</button>
</div>

<script>
/* ---------- p5.js 오디오 리액티브 코드 ---------- */
let mic, fft;
let micEnabled = true, trailMode = false;
let prevAmp=0, sustainW=0, sustainCounter=0;
let time=0, noiseOffset=0, centroid=0;
let circleOffsetY=0, lineOffsetY=0, symbolAlpha=255;
let smoothHighEnergy=0, directionSmooth=1;
let baseWidth;

function setup() {
  pixelDensity(1);
  createCanvas(window.innerWidth, window.innerHeight);
  baseWidth = min(window.innerWidth, 1200);
  noFill();

  mic = new p5.AudioIn(); mic.start();
  fft = new p5.FFT(0.8, 2048); fft.setInput(mic);
  colorMode(RGB, 255);

  const trailBtn = document.getElementById("toggleTrail");
  const clearBtn = document.getElementById("clearScreen");
  const micBtn   = document.getElementById("toggleMic");
  const micIcon  = document.getElementById("micIcon");

  function updateMicVisual(){
    if(micEnabled){ micIcon.src="mic-on.png"; micBtn.classList.add("active"); }
    else { micIcon.src="mic-off.png"; micBtn.classList.remove("active"); }
  }
  updateMicVisual();

  trailBtn.onclick = ()=>{ trailMode=!trailMode; trailBtn.classList.toggle("active",trailMode); };
  micBtn.onclick   = ()=>{
    micEnabled=!micEnabled;
    if(micEnabled){ mic.start(); fft.setInput(mic); }
    else { mic.stop(); }
    updateMicVisual();
  };
  clearBtn.onclick = ()=>background(0);
}

function windowResized(){
  resizeCanvas(window.innerWidth, window.innerHeight);
  baseWidth = min(window.innerWidth, 1200);
}

function draw(){
  if(!trailMode) background(0);

  time += 0.01; noiseOffset += 0.005;
  let smoothedAmp, silent;

  if(!micEnabled){ smoothedAmp=0; silent=true; }
  else {
    let spectrum = fft.analyze();
    let nyquist = sampleRate()/2;
    centroid=0; let totalEnergy=0;
    for(let i=0;i<spectrum.length;i++){
      let freq=(i/spectrum.length)*nyquist;
      let energy=spectrum[i];
      centroid += freq*energy;
      totalEnergy += energy;
    }
    if(totalEnergy>0) centroid /= totalEnergy;

    let level = mic.getLevel();
    let amp = map(level,0,0.1,0,600);
    amp = constrain(amp,0,255);
    smoothedAmp = lerp(prevAmp, amp, 0.1);
    prevAmp = smoothedAmp;
    silent = smoothedAmp < 5;
  }

  circleOffsetY = lerp(circleOffsetY, silent?-150:0, 0.05);
  lineOffsetY   = lerp(lineOffsetY,   silent?150:0, 0.05);
  symbolAlpha   = lerp(symbolAlpha,   silent?255:0, 0.05);

  let bassEnergy = micEnabled? fft.getEnergy(20,250):0;
  let midEnergy  = micEnabled? fft.getEnergy(250,2000):0;
  let rawHigh    = micEnabled? fft.getEnergy(500,8000):0;
  smoothHighEnergy = lerp(smoothHighEnergy, rawHigh, 0.3);

  let spacing   = map(smoothedAmp, 0, 255, 0, 60);
  let numShapes = floor(map(smoothedAmp, 0, 255, 3, 12));

  if(numShapes>3){ sustainCounter++; if(sustainCounter>60) sustainW = min(sustainW+2.5,600);}
  else { sustainCounter=0; sustainW = lerp(sustainW, 0, 0.05); }

  translate(width/2, height/2);

  if(symbolAlpha > 1){
    stroke(255, symbolAlpha);
    strokeWeight(2);
    ellipse(0, circleOffsetY, 80, 80);
    line(-100, lineOffsetY, 100, lineOffsetY);
  }

  if(!(!silent && symbolAlpha < 5)) return;

  function drawComplexPattern(isTop=true){
    let targetDirection = (bassEnergy > smoothHighEnergy)? 1 : -1;
    directionSmooth = lerp(directionSmooth, targetDirection, 0.05);
    let maxRot = map(smoothedAmp, 0, 255, 0, PI/1.2);

    for(let i=0; i<numShapes; i++){
      let t = i / (numShapes - 1);
      let y = i * spacing;
      let rot = map(t, 0, 1, 0, maxRot) * directionSmooth;

      push();
      translate(0, isTop ? -y : -y);
      rotate(isTop ? -rot : rot);
      let sustainFactor = pow(1 - t, 1.5);
      let sustainEffect = sustainW * sustainFactor;

      let w = lerp(baseWidth * 0.15, 80, t) + sustainEffect;
      let h = lerp(1, 80, t);

      let mainAlpha = map(midEnergy, 0, 255, 30, 140);
      stroke(255, mainAlpha);
      strokeWeight(map(t, 0, 1, 0.8, 3));
      ellipse(0, 0, w, h);

      if(smoothHighEnergy > 20){
        let detailCount = floor(map(smoothHighEnergy, 20, 255, 2, 6));
        for(let j=0;j<detailCount;j++){
          let detailT = j / detailCount;
          let detailW = w * (0.2 + detailT * 0.6);
          let detailH = h * (0.2 + detailT * 0.6);
          stroke(255, map(smoothHighEnergy, 20, 255, 30, 90));
          strokeWeight(0.6 + j * 0.4);
          ellipse(0, 0, detailW, detailH);
        }
      }

      if(smoothedAmp > 50){
        stroke(255, map(smoothedAmp, 50, 255, 25, 70));
        strokeWeight(0.4);
        beginShape();
        for(let angle=0; angle<TWO_PI; angle+=0.2){
          let noiseVal = noise(
            cos(angle)*0.01 + noiseOffset + i*0.1,
            sin(angle)*0.01 + noiseOffset + i*0.1,
            time*0.5
          );
          let radius = (w/2) * (0.8 + noiseVal * 0.4);
          vertex(cos(angle)*radius, sin(angle)*radius * (h/w));
        }
        endShape(CLOSE);
      }

      if(bassEnergy > 30){
        stroke(255, map(bassEnergy, 30, 255, 20, 60));
        strokeWeight(map(t, 0, 1, 0.4, 1.6));
        let extend = map(bassEnergy, 30, 255, 1.1, 1.4);
        ellipse(0, 0, w * extend, h * 0.3);
        ellipse(0, 0, w * 0.3, h * extend);
      }

      if(smoothedAmp > 80){
        let particleCount = floor(map(smoothedAmp, 80, 255, 3, 12));
        for(let p=0;p<particleCount;p++){
          let particleAngle = (TWO_PI / particleCount) * p + time * 2;
          let particleRadius = w/2 * (0.6 + sin(time * 3 + p) * 0.2);
          stroke(255, 80);
          strokeWeight(2 + sin(time * 4 + p) * 1);
          point(cos(particleAngle)*particleRadius,
                sin(particleAngle)*particleRadius * (h/w));
        }
      }
      pop();
    }
  }

  drawComplexPattern(true);
  scale(1, -1);
  drawComplexPattern(false);
}

/* ---- 모달 닫기 ---- */
document.getElementById("closeModal").addEventListener("click", () => {
  document.getElementById("infoModal").style.display = "none";
});
</script>
</body>
</html>
