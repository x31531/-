<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>New Sound Symbol</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/addons/p5.sound.min.js"></script>

<style>
  @font-face {
    font-family: 'OnulSamhwa';
    src: url('OnulSamhwagothic-Regular.otf') format('opentype');
  }

  #controls {
    position: fixed;
    top: 12px;
    left: 12px;
    display: flex;
    flex-direction: column;
    gap: 6px;
    z-index: 2000;
  }
  #controls button {
    font-family: 'OnulSamhwa', sans-serif;
    width: 90px;
    height: 30px;
    font-size: 12px;
    color: #fff;
    background: rgba(255,255,255,0.15);
    border: 1px solid rgba(255,255,255,0.3);
    border-radius: 15px;
    backdrop-filter: blur(4px);
    -webkit-backdrop-filter: blur(4px);
    cursor: pointer;
    transition: background 0.25s, transform 0.15s;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  #controls button:hover {
    background: rgba(255,255,255,0.3);
    transform: translateY(-1px);
  }
  #controls button.active {
    background: rgba(255,255,255,0.35);
    border: 1px solid rgba(255,255,255,0.6);
    transform: scale(0.95);
  }
  #toggleMic img { height:16px; width:auto; display:block; }

  @media (max-width: 768px) {
    #controls {
      top:auto; bottom:12px; left:50%;
      transform:translateX(-50%);
      flex-direction:row; gap:8px;
    }
  }

  html,body {margin:0;padding:0;height:100%;background:#000;overflow:hidden;}
  canvas {display:block;}

  #infoModal {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: min(90%, 420px);
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.3);
    border-radius: 20px;
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    padding: 12px 24px 24px 24px;
    color: #fff;
    font-family: 'OnulSamhwa', sans-serif;
    z-index: 3000;
    box-shadow: 0 4px 30px rgba(0,0,0,0.4);
  }
  #infoModal p { font-size:14px; line-height:1.5; margin-bottom:20px; }
  #closeModal {
    display:inline-block; padding:6px 16px; font-size:13px;
    color:#fff; background:rgba(255,255,255,0.2);
    border:1px solid rgba(255,255,255,0.4);
    border-radius:15px;
    backdrop-filter:blur(4px); -webkit-backdrop-filter:blur(4px);
    cursor:pointer; transition:background 0.25s;
  }
  #closeModal:hover { background:rgba(255,255,255,0.35); }

  @media (max-width:768px){
    #infoModal{
      width:92vw; max-height:92vh; overflow-y:auto;
      padding:8px 16px 20px 16px; box-sizing:border-box;
    }
  }
</style>
</head>
<body>

<div id="controls">
  <button id="toggleTrail">누적 ON/OFF</button>
  <button id="clearScreen">클리어</button>
  <button id="toggleMic"><img src="mic-on.png" alt="Mic On Icon" id="micIcon"></button>
</div>

<div id="infoModal">
  <p>
    소리 기호의 리디자인을 통해 유음과 무음이 동등한 무게감을 갖도록 하는 프로젝트입니다.
    스피커에 X표를 치는 등 부정형으로 표현되어 왔던 기존의 무음 기호와는 달리,
    본 작업에서는 유음과 무음 모두가 독립적인 의미를 갖는 기호를 만들고자 했습니다.
    웹을 통해 제가 제안하는 새로운 소리 기호의 작동 원리를 소개합니다.
  </p>
  <button id="closeModal">닫기</button>
</div>

<script>
let mic, fft;
let micEnabled = true, trailMode = false;
let prevAmp=0, sustainW=0, sustainCounter=0;
let time=0, noiseOffset=0, centroid=0;
let circleOffsetY=0, lineOffsetY=0, symbolAlpha=255;
let smoothHighEnergy=0, directionSmooth=1;
let baseWidth;

const ambientSamples = [];
const ambientWindow = 120;
let ambientLevel = 0;

function setup() {
  pixelDensity(1);
  createCanvas(window.innerWidth, window.innerHeight);
  baseWidth = min(window.innerWidth, 1200);
  noFill();

  mic = new p5.AudioIn(); mic.start();
  fft = new p5.FFT(0.8, 2048); fft.setInput(mic);
  colorMode(RGB, 255);

  const trailBtn = document.getElementById("toggleTrail");
  const clearBtn = document.getElementById("clearScreen");
  const micBtn   = document.getElementById("toggleMic");
  const micIcon  = document.getElementById("micIcon");

  function updateMicVisual(){
    if(micEnabled){ micIcon.src="mic-on.png"; micBtn.classList.add("active"); }
    else { micIcon.src="mic-off.png"; micBtn.classList.remove("active"); }
  }
  updateMicVisual();

  trailBtn.onclick = ()=>{ trailMode=!trailMode; trailBtn.classList.toggle("active",trailMode); };
  micBtn.onclick   = ()=>{
    micEnabled=!micEnabled;
    if(micEnabled){ mic.start(); fft.setInput(mic); }
    else { mic.stop(); }
    updateMicVisual();
  };
  clearBtn.onclick = ()=>background(0);
}

function windowResized(){
  resizeCanvas(window.innerWidth, window.innerHeight);
  baseWidth = min(window.innerWidth, 1200);
}

function draw(){
  if(!trailMode) background(0);

  time += 0.01; noiseOffset += 0.005;
  let smoothedAmp, silent;

  if(!micEnabled){
    smoothedAmp=0; silent=true;
  } else {
    let spectrum = fft.analyze();
    let nyquist = sampleRate()/2;
    centroid=0; let totalEnergy=0;
    for(let i=0;i<spectrum.length;i++){
      let freq=(i/spectrum.length)*nyquist;
      let energy=spectrum[i];
      centroid += freq*energy;
      totalEnergy += energy;
    }
    if(totalEnergy>0) centroid /= totalEnergy;

    let level = mic.getLevel();
    ambientSamples.push(level);
    if (ambientSamples.length > ambientWindow) ambientSamples.shift();
    ambientLevel = ambientSamples.reduce((a,b)=>a+b,0) / ambientSamples.length;

    let relative = level / (ambientLevel * 3.0 + 0.001);
    let amp = map(Math.log1p(relative), 0, Math.log1p(2.0), 0, 300);
    amp = constrain(amp, 0, 255);

    smoothedAmp = lerp(prevAmp, amp, 0.1);
    prevAmp = smoothedAmp;
    silent = smoothedAmp < 8;
  }

  circleOffsetY = lerp(circleOffsetY, silent?-150:0, 0.05);
  lineOffsetY   = lerp(lineOffsetY,   silent?150:0, 0.05);
  symbolAlpha   = lerp(symbolAlpha,   silent?255:0, 0.05);

  let spectrum = fft.analyze();
  let bassLimit = floor(spectrum.length * 0.1);
  let midLimit  = floor(spectrum.length * 0.4);

  let bassEnergy=0, midEnergy=0, highEnergy=0;
  for(let i=0; i<bassLimit; i++) bassEnergy += spectrum[i];
  for(let i=bassLimit; i<midLimit; i++) midEnergy += spectrum[i];
  for(let i=midLimit; i<spectrum.length; i++) highEnergy += spectrum[i];

  // 기존보다 상한 높여 선명도 강화
  bassEnergy = map(bassEnergy, 0, bassLimit*255, 0, 160);
  midEnergy  = map(midEnergy,  0, (midLimit-bassLimit)*255, 0, 140);
  highEnergy = map(highEnergy, 0, (spectrum.length-midLimit)*255, 0, 180);

  let spacing   = map(smoothedAmp, 0, 255, 0, 75);
  let numShapes = floor(map(smoothedAmp, 0, 255, 3, 12));

  if(numShapes>3){ sustainCounter++; if(sustainCounter>60) sustainW = min(sustainW + 1.2, 400);}
  else { sustainCounter=0; sustainW = lerp(sustainW, 0, 0.03); }

  translate(width/2, height/2);

  // 모션과 누적의 알파 가중치
  let fadeFactor = trailMode ? 0.6 : 1.0;

  if(symbolAlpha > 1){
    stroke(255, symbolAlpha * fadeFactor);
    strokeWeight(2);
    ellipse(0, circleOffsetY, 80, 80);
    line(-100, lineOffsetY, 100, lineOffsetY);
  }

  if(!(!silent && symbolAlpha < 5)) return;

  function drawComplexPattern(isTop=true){
    let targetDirection = (bassEnergy > highEnergy)? 1 : -1;
    directionSmooth = lerp(directionSmooth, targetDirection, 0.05);
    let maxRot = map(smoothedAmp, 0, 255, 0, PI/1.2) * 1.3;

    for(let i=0; i<numShapes; i++){
      let t = i / (numShapes - 1);
      let y = i * spacing;
      let rot = map(t, 0, 1, 0, maxRot) * directionSmooth;

      push();
      translate(0, isTop ? -y : -y);
      rotate(isTop ? -rot : rot);
      let sustainFactor = pow(1 - t, 1.5);
      let sustainEffect = sustainW * sustainFactor;

      let w = lerp(baseWidth * 0.15, 80, t) + sustainEffect;
      let h = lerp(1, 80, t);

      let mainAlpha = map(midEnergy, 0, 140, 50, 220) * fadeFactor;
      stroke(255, mainAlpha);
      strokeWeight(map(t, 0, 1, 0.8, 3));
      ellipse(0, 0, w, h);

      if(highEnergy > 20){
        let detailCount = floor(map(highEnergy, 20, 180, 2, 6));
        for(let j=0;j<detailCount;j++){
          let detailT = j / detailCount;
          let detailW = w * (0.2 + detailT * 0.6);
          let detailH = h * (0.2 + detailT * 0.6);
          stroke(255, map(highEnergy, 20, 180, 40, 120) * fadeFactor);
          strokeWeight(0.6 + j * 0.4);
          ellipse(0, 0, detailW, detailH);
        }
      }

      if(smoothedAmp > 50){
        stroke(255, map(smoothedAmp, 50, 255, 40, 90) * fadeFactor);
        strokeWeight(0.4);
        beginShape();
        for(let angle=0; angle<TWO_PI; angle+=0.2){
          let noiseVal = noise(
            cos(angle)*0.01 + noiseOffset + i*0.1,
            sin(angle)*0.01 + noiseOffset + i*0.1,
            time*0.5
          );
          let radius = (w/2) * (0.8 + noiseVal * 0.4);
          vertex(cos(angle)*radius, sin(angle)*radius * (h/w));
        }
        endShape(CLOSE);
      }

      if(bassEnergy > 30){
        stroke(255, map(bassEnergy, 30, 160, 30, 70) * fadeFactor);
        strokeWeight(map(t, 0, 1, 0.4, 1.6));
        let extend = map(bassEnergy, 30, 160, 1.1, 1.4);
        ellipse(0, 0, w * extend, h * 0.3);
        ellipse(0, 0, w * 0.3, h * extend);
      }

      if(smoothedAmp > 80){
        let particleCount = floor(map(smoothedAmp, 80, 255, 3, 20));
        for(let p=0;p<particleCount;p++){
          let particleAngle = (TWO_PI / particleCount) * p + time * 2;
          let particleRadius = w/2 * (0.6 + sin(time * 3 + p) * 0.2);
          stroke(255, 100 * fadeFactor);
          strokeWeight(2 + sin(time * 4 + p) * 1);
          point(cos(particleAngle)*particleRadius,
                sin(particleAngle)*particleRadius * (h/w));
        }
      }
      pop();
    }
  }

  drawComplexPattern(true);
  scale(1, -1);
  drawComplexPattern(false);
}

document.getElementById("closeModal").addEventListener("click", () => {
  document.getElementById("infoModal").style.display = "none";
});
</script>
</body>
</html>
